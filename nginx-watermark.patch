--- src/http/modules/ngx_http_image_filter_module.c
+++ src/http/modules/ngx_http_image_filter_module.c
@@ -18,6 +18,7 @@
 #define NGX_HTTP_IMAGE_RESIZE    3
 #define NGX_HTTP_IMAGE_CROP      4
 #define NGX_HTTP_IMAGE_ROTATE    5
+#define NGX_HTTP_IMAGE_WATERMARK 6
 
 
 #define NGX_HTTP_IMAGE_START     0
@@ -46,12 +47,16 @@
 
     ngx_flag_t                   transparency;
     ngx_flag_t                   interlace;
+    ngx_str_t                    watermark;
+    ngx_str_t                    watermark_position;
 
     ngx_http_complex_value_t    *wcv;
     ngx_http_complex_value_t    *hcv;
     ngx_http_complex_value_t    *acv;
     ngx_http_complex_value_t    *jqcv;
     ngx_http_complex_value_t    *shcv;
+    ngx_http_complex_value_t    *wfcv;
+    ngx_http_complex_value_t    *wpcv;
 
     size_t                       buffer_size;
 } ngx_http_image_filter_conf_t;
@@ -68,6 +73,8 @@
     ngx_uint_t                   max_width;
     ngx_uint_t                   max_height;
     ngx_uint_t                   angle;
+    ngx_str_t                    watermark;
+    ngx_str_t                    watermark_position;
 
     ngx_uint_t                   phase;
     ngx_uint_t                   type;
@@ -99,6 +106,8 @@
 static void ngx_http_image_cleanup(void *data);
 static ngx_uint_t ngx_http_image_filter_get_value(ngx_http_request_t *r,
     ngx_http_complex_value_t *cv, ngx_uint_t v);
+static ngx_str_t ngx_http_image_filter_get_str_value(ngx_http_request_t *r,
+    ngx_http_complex_value_t *cv, ngx_str_t v);
 static ngx_uint_t ngx_http_image_filter_value(ngx_str_t *value);
 
 
@@ -158,6 +167,20 @@
       offsetof(ngx_http_image_filter_conf_t, buffer_size),
       NULL },
 
+    { ngx_string("image_filter_watermark"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_image_filter_conf_t, watermark),
+      NULL },
+
+    { ngx_string("image_filter_watermark_position"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_image_filter_conf_t, watermark_position),
+      NULL },
+
       ngx_null_command
 };
 
@@ -531,6 +554,18 @@
         return ngx_http_image_resize(r, ctx);
     }
 
+    ctx->watermark = ngx_http_image_filter_get_str_value(r, conf->wfcv, conf->watermark);
+    ctx->watermark_position = ngx_http_image_filter_get_str_value(r, conf->wpcv, conf->watermark_position);
+
+    if (conf->filter == NGX_HTTP_IMAGE_WATERMARK) {
+
+        if (!ctx->watermark.data) {
+            return NULL;
+        }
+
+        return ngx_http_image_resize(r, ctx);
+    }
+
     ctx->max_width = ngx_http_image_filter_get_value(r, conf->wcv, conf->width);
     if (ctx->max_width == 0) {
         return NULL;
@@ -827,6 +862,10 @@
 
         resize = 0;
 
+    } else if (conf->filter == NGX_HTTP_IMAGE_WATERMARK) {
+
+        resize = 0;
+
     } else { /* NGX_HTTP_IMAGE_CROP */
 
         resize = 0;
@@ -972,6 +1011,57 @@
         gdImageColorTransparent(dst, gdImageColorExact(dst, red, green, blue));
     }
 
+    if (conf->filter == NGX_HTTP_IMAGE_WATERMARK && ctx->watermark.data) {
+
+        u_char  *watermark_name = ngx_palloc(r->pool, ctx->watermark.len+1);
+
+        ngx_cpystrn(watermark_name, ctx->watermark.data, ctx->watermark.len+1);
+
+        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0, "watermark file '%s' used", watermark_name);
+
+        FILE *watermark_file = fopen((const char *)watermark_name, "r");
+
+        if (watermark_file) {
+            gdImagePtr watermark, watermark_mix;
+            ngx_int_t wdx = 0, wdy = 0;
+
+            watermark = gdImageCreateFromPng(watermark_file);
+            fclose(watermark_file);
+
+            if(watermark != NULL) {
+                watermark_mix = gdImageCreateTrueColor(watermark->sx, watermark->sy);
+
+                if (ngx_strcmp(ctx->watermark_position.data, "bottom-right") == 0) {
+                    wdx = dx - watermark->sx - 10;
+                    wdy = dy - watermark->sy - 10;
+                } else if (ngx_strcmp(ctx->watermark_position.data, "top-left") == 0) {
+                    wdx = wdy = 10;
+                } else if (ngx_strcmp(ctx->watermark_position.data, "top-right") == 0) {
+                    wdx = dx - watermark->sx - 10;
+                    wdy = 10;
+                } else if (ngx_strcmp(ctx->watermark_position.data, "bottom-left") == 0) {
+                    wdx = 10;
+                    wdy = dy - watermark->sy - 10;
+                } else if (ngx_strcmp(ctx->watermark_position.data, "center") == 0) {
+                    wdx = dx / 2 - watermark->sx / 2;
+                    wdy = dy / 2 - watermark->sy / 2;
+                }
+
+                gdImageCopy(watermark_mix, dst, 0, 0, wdx, wdy, watermark->sx, watermark->sy);
+                gdImageCopy(watermark_mix, watermark, 0, 0, 0, 0, watermark->sx, watermark->sy);
+                gdImageCopyMerge(dst, watermark_mix, wdx, wdy, 0, 0, watermark->sx, watermark->sy, 75);
+                gdImageDestroy(watermark);
+                gdImageDestroy(watermark_mix);
+
+            } else { ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "watermark file '%s' is not PNG", watermark_name);}
+
+        } else {
+
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "watermark file '%s' not found", watermark_name);
+        }
+        ngx_pfree(r->pool,watermark_name);
+    }
+
     sharpen = ngx_http_image_filter_get_value(r, conf->shcv, conf->sharpen);
     if (sharpen > 0) {
         gdImageSharpen(dst, sharpen);
@@ -1156,6 +1246,28 @@
     return ngx_http_image_filter_value(&val);
 }
 
+static ngx_str_t
+ngx_http_image_filter_get_str_value(ngx_http_request_t *r,
+    ngx_http_complex_value_t *cv, ngx_str_t v)
+{
+    ngx_str_t  val;
+
+    if (cv == NULL) {
+        return v;
+    }
+
+    if (ngx_http_complex_value(r, cv, &val) != NGX_OK) {
+        return v;
+    }
+
+    val.data[val.len]='\0';
+
+    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0, "parse %s len %d ",
+                       val.data, val.len);
+
+    return val;
+}
+
 
 static ngx_uint_t
 ngx_http_image_filter_value(ngx_str_t *value)
@@ -1229,6 +1341,8 @@
             conf->wcv = prev->wcv;
             conf->hcv = prev->hcv;
             conf->acv = prev->acv;
+            conf->wfcv = prev->wfcv;
+            conf->wpcv = prev->wpcv;
         }
     }
 
@@ -1257,6 +1371,10 @@
     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,
                               1 * 1024 * 1024);
 
+    ngx_conf_merge_str_value(conf->watermark, prev->watermark, "");
+
+    ngx_conf_merge_str_value(conf->watermark_position, prev->watermark_position, "bottom-right");
+
     return NGX_CONF_OK;
 }
 
@@ -1332,11 +1450,90 @@
 
             return NGX_CONF_OK;
 
+        } else if (ngx_strcmp(value[i].data, "watermark") == 0) {
+            imcf->filter = NGX_HTTP_IMAGE_WATERMARK;
+
+            ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));
+
+            ccv.cf = cf;
+            ccv.value = &value[++i];
+            ccv.complex_value = &cv;
+
+            if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
+                return NGX_CONF_ERROR;
+            }
+
+            if (cv.lengths == NULL) {
+                imcf->watermark = value[i];
+            } else {
+                imcf->wfcv = ngx_palloc(cf->pool,
+                                       sizeof(ngx_http_complex_value_t));
+                if (imcf->wfcv == NULL) {
+                    return NGX_CONF_ERROR;
+                }
+
+                *imcf->wfcv = cv;
+            }
+
+            return NGX_CONF_OK;
+
         } else {
             goto failed;
         }
     }
 
+    if ((ngx_strcmp(value[i].data, "watermark") == 0) && cf->args->nelts == 4) {
+        imcf->filter = NGX_HTTP_IMAGE_WATERMARK;
+
+        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));
+
+        ccv.cf = cf;
+        ccv.value = &value[++i];
+        ccv.complex_value = &cv;
+
+        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+
+        if (cv.lengths == NULL) {
+            imcf->watermark = value[i];
+        } else {
+            imcf->wfcv = ngx_palloc(cf->pool,
+                                   sizeof(ngx_http_complex_value_t));
+            if (imcf->wfcv == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            *imcf->wfcv = cv;
+        }
+
+        ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));
+
+        ccv.cf = cf;
+        ccv.value = &value[++i];
+        ccv.complex_value = &cv;
+
+        if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
+            return NGX_CONF_ERROR;
+        }
+
+        if (cv.lengths == NULL) {
+            imcf->watermark_position = value[i];
+        } else {
+            imcf->wpcv = ngx_palloc(cf->pool,
+                                   sizeof(ngx_http_complex_value_t));
+            if (imcf->wpcv == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            *imcf->wpcv = cv;
+        }
+
+        return NGX_CONF_OK;
+
+    }
+
+
     if (ngx_strcmp(value[i].data, "resize") == 0) {
         imcf->filter = NGX_HTTP_IMAGE_RESIZE;
 
